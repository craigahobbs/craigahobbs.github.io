# Licensed under the MIT License
# https://github.com/craigahobbs/craigahobbs.github.io/blob/main/LICENSE

include <args.bare>


async function downloadsMain(options):
    args = argsParse(downloadsArguments)
    page = objectGet(args, 'page')
    name = objectGet(args, 'name')
    language = objectGet(args, 'language')

    # Chart page?
    if page == 'chart':
        return downloadsChartPage(args, options)
    endif

    # Package dashboard?
    if name != null && language != null:
        return downloadsDashboard(args)
    endif

    # Render the index page
    downloadsIndex(args)
endfunction


downloadsArguments = argsValidate([ \
    {'name': 'page'}, \
    {'name': 'name'}, \
    {'name': 'language'}, \
    {'name': 'days', 'type': 'int', 'default': 90} \
])


async function downloadsIndex(args):
    trailingDays = objectGet(args, 'days')

    # Document title
    title = 'Package Downloads'
    markdownPrint( \
        '# ' + markdownEscape(title), \
        '', \
        argsLink(downloadsArguments, 'Time Chart', {'page': 'chart'}) \
    )
    documentSetTitle(title)

    # Load the package data
    data = dataValidate(jsonParse(systemFetch('downloads.json')), true)
    dataAverage = downloadsDataAverage(data, trailingDays, true)

    # Create links and compute total downloads
    totalDownloads = 0
    for row in dataAverage:
        rowPackage = objectGet(row, 'Package')
        rowLanguage = objectGet(row, 'Language')
        totalDownloads = totalDownloads + objectGet(row, 'Downloads')

        # Package page link
        objectSet(row, 'Package', argsLink(downloadsArguments, rowPackage, {'name': rowPackage, 'language': rowLanguage}))

        # Package repository link
        if rowLanguage == 'Python':
            packageURL = 'https://pypi.org/project/' + urlEncodeComponent(rowPackage) + '/'
        else:
            packageURL = 'https://www.npmjs.com/package/' + urlEncodeComponent(rowPackage)
        endif
        objectSet(row, 'Language', '[' + markdownEscape(rowLanguage) + '](' + packageURL + ')')
    endfor
    dataSort(dataAverage, [['Downloads', true]])
    arrayPush(dataAverage, {'Package': '**Total**', 'Language': '', 'Downloads': totalDownloads})

    # Render the package downloads table
    dataTable(dataAverage, { \
        'fields': ['Package', 'Language', 'Downloads'], \
        'formats': { \
            'Package': {'markdown': true}, \
            'Language': {'markdown': true}, \
            'Downloads': {'align': 'right', 'header': 'Monthly Downloads'} \
        }, \
        'precision': 0 \
    })
endfunction


async function downloadsChartPage(args, options):
    trailingDays = objectGet(args, 'days')

    # Render the title
    title = 'Downloads Chart'
    documentSetTitle(title)
    markdownPrint( \
        argsLink(downloadsArguments, 'Back', {'page': null}), \
        '', \
        '# ' + markdownEscape(title) \
    )

    # Compute the color legend order
    data = downloadsDataLoad()
    dataAverage = downloadsDataAverage(data, trailingDays)
    dataSort(dataAverage, [['Downloads', true]])
    colorOrder = []
    for row in dataAverage:
        arrayPush(colorOrder, objectGet(row, 'Unique'))
    endfor

    # Add the featured column
    featuredMap = objectGet(options, 'featured') || {}
    dataCalculatedField( \
        data, \
        'Featured', \
        'objectGet(objectGet(featuredMap, Package), Language, false)', \
        {'featuredMap': featuredMap} \
    )

    # First featured, then non-featured
    for isFeatured in [true, false]:
        # Create the chart
        dataMonthly = downloadsDataMonthly(dataFilter(data, '!!Featured == isFeatured', {'isFeatured': isFeatured}))
        if !dataMonthly:
            continue
        endif
        chartWidth = mathFloor(mathMax(600, windowWidth() - 4 * documentFontSize()))
        chartHeight = mathFloor(0.3 * chartWidth)
        dataLineChart(dataMonthly, { \
            'title': 'Monthly Downloads' + if(isFeatured, ' (Featured)', ''), \
            'width': chartWidth, \
            'height': chartHeight, \
            'x': 'Month', \
            'y': ['Downloads'], \
            'color': 'Unique', \
            'colorOrder': colorOrder, \
            'yTicks': {'start': 0, 'count': 5}, \
            'precision': 0, \
            'datetime': 'day' \
        })
    endfor

    # Redraw on resize
    windowSetResize(systemPartial(downloadsChartPage, args, options))
endfunction


async function downloadsDashboard(args):
    name = objectGet(args, 'name')
    language = objectGet(args, 'language')
    trailingDays = objectGet(args, 'days')

    # Document title
    title = name + ' (' + language + ') Downloads'
    markdownPrint( \
        argsLink(downloadsArguments, 'Back', {'name': null, 'language': null}), \
        '', \
        '# ' + markdownEscape(title) \
    )
    documentSetTitle(title)

    # Load the package data
    data = downloadsDataLoad()

    # Filter to this package's data
    filterExpr = 'Package == packageName && Language == packageLanguage'
    filterVars = {'packageName': name, 'packageLanguage': language}
    data = dataFilter(data, filterExpr, filterVars)

    # Compute the monthly average
    dataMonthly = downloadsDataMonthly(data)
    monthlyAverageData = downloadsDataAverage(data, trailingDays, true)
    monthlyAverage = objectGet(arrayGet(monthlyAverageData, 0), 'Downloads')

    # Compute the minimum date
    minDateData = dataAggregate(data, { \
        'measures': [ \
            {'field': 'Date', 'function': 'min'} \
        ] \
    })
    minDateMin = objectGet(arrayGet(minDateData, 0), 'Date')
    minDate = datetimeNew(datetimeYear(minDateMin), datetimeMonth(minDateMin), datetimeDay(minDateMin) + trailingDays)

    # Compute the daily trailing average
    for row in data:
        rowDate = objectGet(row, 'Date')
        if rowDate >= minDate:
            averageDownloadsData = downloadsDataAverage(data, trailingDays, false, rowDate)
            averageDownloads = objectGet(arrayGet(averageDownloadsData, 0), 'Downloads')
            objectSet(row, 'Average Downloads', averageDownloads)
        endif
    endfor

    # Render the monthly line chart
    chartWidth = mathFloor(mathMax(600, windowWidth() - 4 * documentFontSize()))
    chartHeight = mathFloor(mathMax(200, mathFloor(0.2 * chartWidth)))
    if dataMonthly:
        dataLineChart(dataMonthly, { \
            'title': 'Monthly Downloads - ' + name, \
            'width': chartWidth, \
            'height': chartHeight, \
            'x': 'Month', \
            'y': ['Downloads'], \
            'yTicks': {'start': 0}, \
            'xLines': [ \
                {'value': downloadsDataAverageMinDate(dataMonthly, trailingDays, 'Month'), 'label': ''} \
            ], \
            'yLines': [ \
                {'value': monthlyAverage} \
            ], \
            'datetime': 'day', \
            'precision': 1 \
        })
    endif

    # Render the daily line chart
    dailyLineChart = { \
        'title': 'Daily Downloads - ' + name, \
        'width': chartWidth, \
        'height': chartHeight, \
        'x': 'Date', \
        'y': ['Average Downloads', 'Downloads'], \
        'yTicks': {'start': 0}, \
        'yLines': [ \
            {'value': if(averageDownloads != null, averageDownloads, monthlyAverage)} \
        ], \
        'datetime': 'day', \
        'precision': 1 \
    }
    if averageDownloads != null:
        objectSet(dailyLineChart, 'xLines', [ \
            {'value': downloadsDataAverageMinDate(data, trailingDays), 'label': ''} \
        ])
    endif
    dataLineChart(data, dailyLineChart)

    # Render the monthly table by most recent
    if dataMonthly:
        dataSort(dataMonthly, [['Month', true]])
        dataCalculatedField( \
            dataMonthly, \
            '% Average', 'numberToFixed((100 * (Downloads - monthlyAverage) / monthlyAverage), 1, true) + "%"', \
            {'monthlyAverage': monthlyAverage} \
        )
        dataTable(dataMonthly, { \
            'fields': ['Month', 'Downloads', '% Average'], \
            'formats': { \
                'Downloads': {'align': 'right'} \
            }, \
            'datetime': 'month', \
            'precision': 0 \
        })
    endif

    # Redraw on resize
    windowSetResize(systemPartial(downloadsDashboard, args))
endfunction


async function downloadsDataLoad():
    data = dataValidate(jsonParse(systemFetch('downloads.json')), true)

    # Compute the unique package names
    nameLanguages = {}
    for row in data:
        name = objectGet(row, 'Package')
        language = objectGet(row, 'Language')
        languages = objectGet(nameLanguages, name)
        if !languages:
            objectSet(nameLanguages, name, {language: true})
        else:
            objectSet(languages, language, true)
        endif
    endfor
    for row in data:
        name = objectGet(row, 'Package')
        language = objectGet(row, 'Language')
        if arrayLength(objectKeys(objectGet(nameLanguages, name))) == 1:
            objectSet(row, 'Unique', name)
        elif language == 'Python':
            objectSet(row, 'Unique', name + ' (py)')
        else:
            objectSet(row, 'Unique', name + ' (js)')
        endif
    endfor

    return data
endfunction


function downloadsDataMonthly(data):
    # Filter-out the current month
    today = datetimeToday()
    maxDate = datetimeNew(datetimeYear(today), datetimeMonth(today), 1)
    dataFiltered = dataFilter(data, 'Date < maxDate', {'maxDate': maxDate})

    # Compute the month field
    dataCalculatedField(dataFiltered, 'Month', 'datetimeISOParse(stringSlice(datetimeISOFormat(Date, true), 0, 7) + "-01")')

    # Aggregate by month
    return dataAggregate(dataFiltered, { \
        'categories': ['Language', 'Package', 'Unique', 'Month'], \
        'measures': [ \
            { \
                'field': 'Downloads', \
                'function': 'sum' \
            } \
        ] \
    })
endfunction


function downloadsDataAverage(data, trailingDays, monthly, maxDate):
    # Filter the data
    minDate = downloadsDataAverageMinDate(data, trailingDays, null, maxDate)
    if maxDate:
        dataFiltered = dataFilter(data, 'Date >= minDate && Date <= maxDate', {'minDate': minDate, 'maxDate': maxDate})
    else:
        dataFiltered = dataFilter(data, 'Date >= minDate', {'minDate': minDate})
    endif

    # Compute the average
    dataAverage = dataAggregate(dataFiltered, { \
        'categories': ['Language', 'Package', 'Unique'], \
        'measures': [ \
            {'field': 'Downloads', 'function': 'sum'} \
        ] \
    })
    dataCalculatedField(dataAverage, 'Downloads', 'Downloads / trailingDays', {'trailingDays': trailingDays})

    # Monthly average?
    if monthly:
        dataCalculatedField(dataAverage, 'Downloads', 'Downloads * 30')
    endif

    return dataAverage
endfunction


function downloadsDataAverageMinDate(data, trailingDays, field, maxDate):
    field = if(field, field, 'Date')
    if !maxDate:
        maxDateData = dataAggregate(data, { \
            'measures': [ \
                {'field': field, 'function': 'max'} \
            ] \
        })
        maxDate = objectGet(arrayGet(maxDateData, 0), field)
    endif
    return datetimeNew(datetimeYear(maxDate), datetimeMonth(maxDate), datetimeDay(maxDate) - trailingDays)
endfunction
